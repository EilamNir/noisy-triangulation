# Meeting Notes

## 2023-04-19 meeting notes

- Need to have two types of path sections:
  - straight line in any 3d direction
    - Constant speed in all directions
    - later add option of constant acceleration in z direction (but keep speed continues)
  - X-Y turn
    - constant radius of turn in xy plane
    - speed in xy plane should stay constant
    - constant z speed
    - arguments for generating the section:
      - turn degrees per second - about 3 [deg/sec]
        - probably want this in radians per second
      - XY speed (should default to keep the same speed it had before) - about 50 [m/s]
      - Z speed (should default to keep the same speed it had before) - about 10 [m/s] or less
      - section length in seconds
        - maybe add an option to use length or total degrees turned, to help make creating this section not depend on speed calculation outside the function
- Work with radians instead of degrees
- Work with Azimuth and Elevation instead of $\phi$ and $\theta$
- Sensors
  - Each sensor should have:
    - range
      - normal noise should have sigma of about 10 to 20 meters
    - Azimuth (from north direction) and Elevation (north should be down, meaning z grows downwards)
      - Elevation should be between $[0-\pi]$
      - Azimuth should be calculated as $arctan(\frac{\Delta y}{\Delta x})$ where x is range and y is yaw
        - The right handed coordinates are: (East, North, Up)
      - normal noise for both should have sigma of about 5 milliradians
  - At first, all sensors should only measure range
    - later have multiple sensors of different types working together
  - Currently the sigma of each sensor will be known to our estimation algorithm
  - Currently the info we get from the sensors should be synchronized (both to each other and to the true value)
    - Later add a delay from the true position to the sensor position
      - maybe make it also depend on range, and make the delay noisy?
    - Later add dropped measurements
      - means we probably already need to add a time tag to each sensor measurement
  - Sensors should have measurement speed of 1 to 5 Hz
    - Probably make it a parameter per sensor
    - The true target position should probably update more frequently
- Sensor positioning:
  - first sensor about 5 km before path starting point
  - second sensor about 5 to 10 km after ending point
  - other sensors (at least one) in arbitrary points
  - all sensors should be on ground level
- Location Estimations
  - Implement estimations for generic heterogeneous sensors from the start
  - At first only estimate one point at a time, from all data available from the sensors about this point, without taking into account the speed or any other info about the previous points
  - Estimation principles:
    - $y$ is a vector of measurements (ranges and angles from multiple sensors)
    - $x$ is the true position vector
    - $y$ can be obtained as $y=h(x) + v$ where $h$ is some general function
    - the linear estimator is: $\hat{x} = {argmin}_x(||y-Hx||^2)$
      - the solution is $\hat{x}_{LS} = (H^\dagger H)^{-1} H^\dagger y$
    - non-linear estimations:
      - to get a non-linear estimator, we need to use a taylor series of first order of $h$, and an initial guess $x_0$ to expand the series around
        - in our case, the initial guess $x_0$ for the first point in the path will be the true point of the target, and $x_0$ for all other points will be the last estimated position.
      - to get the estimate, we will use the equation $y \approx h(x_0) + \frac{\partial h}{\partial x}\big |_{x=x_0} (x-x_0)$
      - we will define $H=\frac{\partial h}{\partial x}\big |_{x=x_0}$
      - our solution is now to use regular least-squares for minimizing $y-h(x_0)=H(x-x_0)$
        - This gives us the LS problem of $\hat{x}=argmin_x(||(y-h(x_0)+Hx_0)-Hx||^2)$
        - the straightforward solution to this is $\hat{x} = H^{-1}(y - h(x_0)) + x_0$
        - if $H$ is not square, we must use the general LS solution instead, which is $\hat{x}=(H^\dagger H)^{-1}H^\dagger (y-h(x_0)+Hx_0)$
      - we can iterate over this function, each time using the last calculated $x$ as $x_0$
        - for range sensors, this should usually converge after about 3 iterations
        - for angle sensors it might take a longer time to converge
          - we need to remember to keep the angles between $Az \in [0, 2 \pi], Elevation \in [0, \pi]$
      - we need to calculate $cov(\hat{\Delta x}) = cov(\hat{x}-x_0)=cov((H^\dagger H)^{-1} H^\dagger \Delta y)=Jcov(\Delta y)J^\dagger$
        - we defined $J = (H^\dagger H)^{-1} H^\dagger$ as $J$ is constant and can be calculated ahead of time once
- CRML project definition report
  - take tasks from initial mail and fill in appropriate dates for tasks gantt
    - add filtering as a task
  - main reference will be the book from the first mail
    - other references will be added later when we decide on what to continue with
  - no need to spend too much time on this report

## 2023-05-02 meeting notes

- Change distance and time of path to be 100km straight, 90 km turn, and another 100 km straight
- Add cov calculation to estimate the error
  - Use the last $\hat{x}$ estimated, and the true $x_0$
  - Only run it at the end, and only for the true path
  - If we mix azimuth and distances, the calculation won't work because of mixing of units, and we will need to weight it with a matrix with a diagonal of $\frac{1}{\sigma^2}$
    - Don't do it right now, stick with distances for now
  - To get the error, we can take $sqrt(trace(\text{cov matrix}))$
    - We can split it to error in xy plane and error in z, as the error should be very different between those
- Compare the error to Monte Carlo
  - run 100-200 simulations
  - take the square root of the distance between the points on the true path to the estimated path
  - averaging all 100 runs should give us something that is close to the cov we calculated
    - do this for each coordinate separately
      - We will get an average error for each axis, compare to the cov we calculated
      - use pythagoras to get the xy error and compare to the trace of the xy of the cov
      - plot a graph of the real errors (from Monte Carlo) and the expected errors (from cov calculation) for each point in time
      - the cov should stay the same for all simulations, we only need to calculate it once
    - The error we get will depend on sensor locations
- Test set:
  - The path should stay constant for all simulations, and be in hight of 1000 m
  - simulations:
    - put 3 sensors as they are now (one before the path, one after the path, one in some other location)
    - Put all 3 sensors around the same point $(-1000, -4000, 0)$
    - put the 3 sensors as they are now, but in hight of 5000 m
    - use more than 3 sensors
- We should only change the geometry (path/sensors) or the noise, as those are the only things affecting the cov
- show on a graph the errors (MC and COV) for the different paths
- If all the sensors are the same, we get:
  - $cov = JJ^\dagger \cdot cov(\Delta y) = (H^\dagger H)^{-1} \cdot cov(\Delta y)$
  - therefore:
  - $cov =[(H^\dagger H)^{-1} H^\dagger] [H (H^\dagger H)^{-1}] \cdot cov(\Delta y) = (H^\dagger H)^{-1}\sigma_r^2$
  - where $(H^\dagger H)^{-1}$ depends on the geometry, and $\sigma_r^2$ depends on noise
- We can also estimate the error:
  - $\sqrt{tr((H^\dagger H)^{-1})} = GDOP$
    - GDOP stands for Geometric Dilution Of Precision
  - in GPS there is a rule of thumb: $DOP>6$ is bad, $DOP<6$ is good
  - We can also calculate VDOP and HDOP (vertical/horizontal DOP) by taking only the hight or xy in the matrix $(H^\dagger H)^{-1}$
- This is a tool that allows us to estimate performance without doing any experiments
- Adding a sensor makes it so we don't need to do more than a single iteration to converge
- We shouldn't use $inv$ in Matlab, and instead do something like $(H'H)\char`\\H'$ or $(eye/(H'H))H'$

## 2023-05-21

- Change the plots of the cov error to have xy error as one graph and z as another, so we only have 2 error graphs on each plot instead of 3.
  - Need to change the error to be the square of the cov error, so the error will be in meters.
  - The error is equal to the $\sigma$ times the DOP (in meters, as $\sigma$ is in meters and DOP is unit-less).
- Filters:
  - Daniel will send us reading materials about Kalman filter.
  - There is an intro exercise that Daniel will send us. We don't need to solve it perfectly, just to get the gist of it.
  - After we implement the Kalman filter we can move on to more advanced filters.
- Trilateration without iterations:
  - To get the location without iterations, we need to change the measurements so they are linear.
  - Until now, we assumed that our measurements are $r_i = \sqrt{dx_i^2+dy_i^2+dz_i^2}+n_i$, where $n_i$ is the noise of the measurements.
    - These are non-linear equations
  - Instead of these equations, we can write linear equations:
    - $r_1^2 = dx_1^2+dy_1^2+dz_1^2+n_i$
    - $r_2^2 = dx_2^2+dy_2^2+dz_2^2+n_i$
    - ...
    - The noise of these equations gets changed a little, so they are not exactly correct.
  - We can use the first and second equation to get:
    - $r_1^2-r_2^2 = dx_1^2-dx_2^2 + dy_1^2-dy_2^2 + dz_1^2-dz_2^2 + n_1 - n_2$
    - $dx_1^2-dx_2^2 = (x-x_1)^2 - (x-x_2)^2=(x-x_1-x+x_2)(2x+x_1+x_2)=(x_2-x_1)(2x+x_1+x_2)$
  - We got one linear equation in x out of the equations for the first and second distance.
  - Using at least 4 distances (meaning 4 sensors), we can get 3 sets of independent equations, which we can solve to get the location.
    - We will be able solve these equations using a single matrix multiplication, without iterations.
  - After implementing this, we should try and plot the error of this estimator against the other errors we have (cov and MC of iterative)
    - The cov calculation for this will be different than the cov of the iterative, but should give about the same cov
  - Daniel will send us the first paper that used this method for distances.
  - This method can also be used for angles.
